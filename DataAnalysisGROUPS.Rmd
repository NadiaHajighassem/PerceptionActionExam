---
title: "Data analysis"
author: "Nadia and Katharina"
output:
  html_document:
      toc: yes
      number_sections: no
      toc_float: yes
      theme: united
      highlight: espresso
      css: '../../varia/standard.css'
geometry: margin=1in
knit: (function(inputFile, encoding) {
  browseURL(
    rmarkdown::render(
      inputFile,
      encoding = encoding,
      output_dir = "html.file",
      output_file = "DataAnalysis.html"))})
---

```{r setuP}
## Setup chunk
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)

#Aesthetic setup
theme_set(theme_ipsum())
bar_colour <- "#0e3b85"
```

Here i am just loading the packages and setting up our working directory. I am also specifying, which group we are looking at.

```{r loading packages}
pacman::p_load(
  "XML",
  "tidyverse",
  "fs",
  "assertthat",
  "stringi",
  "dtw",
  "RTransferEntropy",
  "signal",
  "conflicted",
  "Rcpp",
  "future",
  "fastICA",
  "hrbrthemes"
)

## Making sure we are in the right directory
wd <- getwd()
if (basename(wd) != "PerceptionActionExam") {
  setwd("./PerceptionActionExam")
}

# set the directory for the data
# note, path_home() will return the path to your home directory
# your home directory is the one that contains your documents, downloads, etc.
#data_dir <- path_home() %>% 
#  path("Documents", "GitHub", "PerceptionActionExam", "data", "tsvs") ## Nadia's path

data_dir <- path_home() %>% 
  path("Desktop","UNI", "3.semester", "Perception & Action", "PerceptionActionExam", "data", "tsvs") ## Katharina's path


# The available conditions and their start and end frame indices
# to use the whole file, just set the value for the condition to c(NA, NA)
conditions <- list(
  jointlead = c(NA, NA),
  followlead = c(NA, NA),
  leadfollow = c(NA, NA),
  custom = c(NA, NA)
)

# Calling functions
source("Functions.R")
```

And so, some more boring stuff...This is just getting the labels so we can make sure that the tracked markers match up with what we expected, really, this shouldn't go wrong, but if you don't check this kind of thing you'll end up scratching your head later wondering why everything broke.

```{r}
# load the labels from the XML file

# load the XML file
xmlfile <- xmlParse("PerAct23_LabelList.xml")

# get the labels, which are in the following format:
# <QTM_Label_List_Ver_1.00>
#     <Trajectories>
#         <Trajectory>
#             <Name>A_head_top</Name>
#             <Color R="0" G="147" B="0"/>
#         </Trajectory>
#     </Trajectories>
# </QTM_Label_List_Ver_1.00>

# get the trajectory names
traj_names <- xpathSApply(xmlfile, "//Trajectory/Name", xmlValue)

# get the trajectory colors
traj_colors <- xpathSApply(xmlfile, "//Trajectory/Color", xmlAttrs)

# convert the colors to hex
traj_colors <- rgb(
  as.numeric(traj_colors[1,]),
  as.numeric(traj_colors[2,]),
  as.numeric(traj_colors[3,]),
  alpha = 255,
  maxColorValue = 255
)


# combine the names and colors into a data frame
traj_labels <- data.frame(
  traj_names,
  traj_colors,
  stringsAsFactors = FALSE
)

rm(xmlfile, traj_names, traj_colors)
```

Finally loading in data hehehe (insert elmo meme with fire in the background)

Aditionally, this code is transforming data from a wide format, where each marker's x, y, and z coordinates are in separate columns, to a long format where all the coordinates are in a single column. It then adds more information about each observation (subject, axis, and marker) before pivoting it back to a wide format.

```{r }
## the code lists files in the specified directory that have names ending with ".tsv" and stores the list of file paths in the variable traj_files.
traj_files <- fs::dir_ls(data_dir, regexp = "\\.tsv$")
```

## Loading the data in and giving meaningful names

```{r}
# Now we can actually load in the data. When we are loading in the data, we are also renaming out list to be the name of the individual groups and conditions 
traj_data_list <- list()

for (file_path in traj_files) {
  # Load the data from the file
  traj_data <- process_qtm_tsv(file_path)
  
  # Extract the group number and condition from the filename
  group_number <- sub(".*group([0-9]+).*\\.tsv", "\\1", basename(file_path))
  condition <- traj_data$metadata$condition
  
  # Create a unique identifier for the combination of group number and condition
  group_condition_identifier <- paste0("group", group_number, "_", condition)
  
  # Check if a dataframe with this identifier already exists in the list
  if (group_condition_identifier %in% names(traj_data_list)) {
    # If it exists, append the data to the existing dataframe
    traj_data_list[[group_condition_identifier]]$data <- rbind(traj_data_list[[group_condition_identifier]]$data, traj_data$data)
  } else {
    # If it doesn't exist, create a new dataframe and add it to the list
    traj_data_list[[group_condition_identifier]] <- traj_data
  }
}

# Now, traj_data_list contains individual lists for each unique combination of group number and condition
```

## Adding condition and group columns, so we can have nice individual dataframes later on

```{r}
traj_data_list <- lapply(traj_data_list, function(x) {
  # Add condition and group information to the data frame
  x$data$condition <- x$metadata$condition
  
  # Set x$data$group to be the list name
  x$data$group <- basename(file_path)
  
  return(x)
})
```

## So up until now the lists have been in one dataframe, so lets split them into multiple dataframes!

```{r}
library(dplyr)

# Assuming traj_data_list is a list of data frames with both 'data' and 'metadata'
for (i in seq_along(traj_data_list)) {
  x <- traj_data_list[[i]]
  
  # Check if 'data' and 'metadata' components exist in each list element
  if (!all(c("data", "metadata") %in% names(x))) {
    warning("List element does not have 'data' and/or 'metadata'. Skipping.")
    next
  }
  
  # Extract condition and group information from the file path
  file_path <- names(traj_data_list)[i]
  condition <- sub(".*group[0-9]+_([^_\\.]+).*", "\\1", file_path)
  group_number <- sub(".*group([0-9]+).*", "\\1", file_path)
  
  # Add condition and group information to the data frame
  x$data$condition <- condition
  x$data$group <- paste0("group", group_number)
  
  # Create a new data frame with the processed data and name it
  new_df_name <- paste0("group", group_number, "_", condition)
  assign(new_df_name, x$data)
}

```

## Turning condition and group into factors and ensuring all marker names are not the same

```{r}
# Get a list of objects in the global environment
all_objects <- ls()

 # regex
regex_pattern <- "^group([0-9]|1[0-3])_"

# Filter objects that match the pattern
group_objects <- grep(regex_pattern, all_objects, value = TRUE)

# Loop through each object and apply the operations
for (df_name in group_objects) {
  # Extract the current data frame
  df <- get(df_name)
  
  # Check if 'condition' and 'group' columns exist
  if (!all(c("condition", "group") %in% names(df))) {
    warning(paste("Data frame", df_name, "does not have 'condition' and/or 'group' columns. Skipping."))
    next
  }
  
  # Add factors for condition and group
  df$condition <- factor(df$condition)
  df$group <- factor(df$group)
  
  # Print the data frame name
  cat("Data frame:", df_name, "\n")
  
  # Print the first few rows of the data frame
  print(head(df))
  
  # Ensure all marker names are the same
  marker_names <- unique(df %>% select(contains("_x")) %>% names() %>% stri_replace_last_regex("_x", ""))
  
  assertthat::assert_that(
    all(marker_names == traj_labels$traj_names),
    msg = paste("Not all marker names are the same in Data frame", df_name)
  )
  
  cat("\n")
}
```

## Going from wide format to long format

```{r}
# Get a list of objects in the global environment
all_objects <- ls()

# Define a regular expression to match group identifiers followed by a number between 0 and 13
regex_pattern <- "^group([0-9]|1[0-3])_"

# Filter objects that match the pattern
group_objects <- grep(regex_pattern, all_objects, value = TRUE)

# Loop through each object and apply the operations
for (df_name in group_objects) {
  # Extract the current data frame
  df <- get(df_name)
  
  # Check if 'condition' and 'group' columns exist
  if (!all(c("condition", "group") %in% names(df))) {
    warning(paste("Data frame", df_name, "does not have 'condition' and/or 'group' columns. Skipping."))
    next
  }
  
  # Pivot the data
  df <- df %>% 
    pivot_longer(
      cols = contains("_x") | contains("_y") | contains("_z"),
      cols_vary = "slowest",
      names_to = "marker",
      values_to = "value"
    ) %>%
    mutate(
      subject = stri_replace_first_regex(marker, "^([AB])_.*", "$1"),
      axis = stri_extract_last_regex(marker, "[xyz]$"),
      marker = stri_replace_first_regex(marker, "^[AB]_([a-zA-Z_]+)_[xyz]$", "$1")
    ) %>%
    # Move axes to columns
    pivot_wider(
      names_from = axis,
      values_from = value
    )
  
  # Assign the modified data frame back to the original variable
  assign(df_name, df)
  
  # Print the data frame name
  cat("Data frame:", df_name, "\n")
  
  # Print the first few rows of the pivoted data frame
  print(head(df))
  
  cat("\n")
}
```

## NA checking

For the most accurate analysis we want to include the following markers: Head, both hands and elbows, and chest. Before proceeding we check for NA's to verify none of these markers have too many NAs.

```{r}
# Get a list of objects in the workspace
objects <- ls()

# Filter objects that start with "group" followed by a number and underscore
group_dataframes <- grep("^group\\d+_", objects, value = TRUE)

# Iterate over the matching dataframes and apply the operation
for (df_name in group_dataframes) {
  df <- get(df_name)  # Get the dataframe
  
  # Identify columns with NAs
  na_columns <- colnames(df)[colSums(is.na(df)) > 0]
  
  # Select "marker" column and columns with NAs
  columns_to_summarize <- c("marker", na_columns)
  
  result <- df %>%
    select(all_of(columns_to_summarize)) %>%
    group_by(marker) %>%
    summarise(across(everything(), ~ sum(is.na(.)))) %>%
    arrange(across("x"))
  
  print(result)
}

```

## Visualising the NAs

```{r}
# Get a list of objects in the workspace
objects <- ls()

# Filter objects that start with "group" followed by a number and underscore
group_dataframes <- grep("^group\\d+_", objects, value = TRUE)

# Iterate over the matching dataframes and apply the operation
for (df_name in group_dataframes) {
  df <- get(df_name)  # Get the dataframe
  
  # Identify columns with NAs
  na_columns <- colnames(df)[colSums(is.na(df)) > 0]
  
  # Select "marker" column and columns with NAs
  columns_to_summarize <- c("marker", na_columns)
  
  result <- df %>%
    select(all_of(columns_to_summarize)) %>%
    group_by(marker) %>%
    summarise(across(everything(), ~ sum(is.na(.)))) %>%
    arrange(across("x"))
  
  # Plotting
  p <- ggplot(result, aes(x = marker, y = x)) +
    geom_bar(stat = "identity") +
    labs(title = df_name, x = "Marker", y = "Number of NA")+
    theme_minimal()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # Print each plot
  print(p)
}

```

```{r}
##JOINT LEAD COMBINED PLOT##

# Get a list of objects in the workspace
objects <- ls()

# Filter objects that end with "_JointLead"
joint_lead_dataframes <- grep("_jointlead$", objects, value = TRUE)

# Create an empty list to store dataframes
df_list <- list()

# Iterate over the matching dataframes and store them in the list
for (df_name in joint_lead_dataframes) {
  df <- get(df_name)  # Get the dataframe
  df_list[[df_name]] <- df
}

# Combine dataframes into a single dataframe with an additional 'group' column
combined_df <- bind_rows(df_list, .id = "group")

# Identify columns with NAs
na_columns <- colnames(combined_df)[colSums(is.na(combined_df)) > 0]

# Select "marker" column and columns with NAs
columns_to_summarize <- c("marker", na_columns, "group")

# Summarize the number of NAs for each marker
result <- combined_df %>%
  select(all_of(columns_to_summarize)) %>%
  group_by(group, marker) %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  arrange(across("marker"))

# Plotting
p <- ggplot(result, aes(x = marker, y = x, fill = as.factor(group))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Combined JointLead Dataframes Total NA's", x = "Marker", y = "Number of NA") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "Group")

# Print the combined plot
print(p)

##LEADFOLLOW COMBINED PLOT##
# Get a list of objects in the workspace
objects <- ls()

# Filter objects that end with "_leadfollow"
joint_lead_dataframes <- grep("_leadfollow$", objects, value = TRUE)

# Create an empty list to store dataframes
df_list <- list()

# Iterate over the matching dataframes and store them in the list
for (df_name in joint_lead_dataframes) {
  df <- get(df_name)  # Get the dataframe
  df_list[[df_name]] <- df
}

# Combine dataframes into a single dataframe with an additional 'group' column
combined_df <- bind_rows(df_list, .id = "group")

# Identify columns with NAs
na_columns <- colnames(combined_df)[colSums(is.na(combined_df)) > 0]

# Select "marker" column and columns with NAs
columns_to_summarize <- c("marker", na_columns, "group")

# Summarize the number of NAs for each marker
result <- combined_df %>%
  select(all_of(columns_to_summarize)) %>%
  group_by(group, marker) %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  arrange(across("marker"))

# Plotting
p <- ggplot(result, aes(x = marker, y = x, fill = as.factor(group))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Combined LeadFollow Dataframes Total NA's", x = "Marker", y = "Number of NA") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "Group")

# Print the combined plot
print(p)


##COMBINED FOLLOWLEAD SETS ##

# Get a list of objects in the workspace
objects <- ls()

# Filter objects that end with "_followlead"
joint_lead_dataframes <- grep("_followlead$", objects, value = TRUE)

# Create an empty list to store dataframes
df_list <- list()

# Iterate over the matching dataframes and store them in the list
for (df_name in joint_lead_dataframes) {
  df <- get(df_name)  # Get the dataframe
  df_list[[df_name]] <- df
}

# Combine dataframes into a single dataframe with an additional 'group' column
combined_df <- bind_rows(df_list, .id = "group")

# Identify columns with NAs
na_columns <- colnames(combined_df)[colSums(is.na(combined_df)) > 0]

# Select "marker" column and columns with NAs
columns_to_summarize <- c("marker", na_columns, "group")

# Summarize the number of NAs for each marker
result <- combined_df %>%
  select(all_of(columns_to_summarize)) %>%
  group_by(group, marker) %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  arrange(across("marker"))

# Plotting
p <- ggplot(result, aes(x = marker, y = x, fill = as.factor(group))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Combined FollowLead Dataframes total NA's", x = "Marker", y = "Number of NA") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_discrete(name = "Group")

# Print the combined plot
print(p)
```

Unfortunately, the elbow markers have a lot of NA's. According to our plots, "head_top" is consistently low in NA's, while the distribution of NA's for hands and chest is not consistent throughout the groups, we continue with checking the euclydian distance to further verify the validity of choosing said markers.

## Euclidean distance

## Gap-filling

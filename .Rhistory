<<<<<<< Updated upstream
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"group",
n,
"_x_position_before_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# Apply the linear gap fill function to each column, by condition
selected_traj_data <- selected_traj_data %>%
group_by(condition, subject, marker) %>%
mutate_at(
vars(x, y, z),
~ gap_fill_linear(.)
)
# Plot a single marker's x, y, and z values after gap filling
plot_after <- selected_traj_data %>%
dplyr::filter(group == n) %>%
dplyr::filter(marker == markers_of_interest[sel_idx]) %>%
ggplot(aes(x = elapsed_time, y = x, color = subject)) +
geom_line() +
facet_wrap(c(~condition)) +
labs(
x = "Elapsed time",
y = "Marker X position",
title = paste("Marker", markers_of_interest[sel_idx], "X position after gap filling", "group", n)
)
print(plot_after)
ggsave(
plot_after,
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"group",
n,
"_x_position_after_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
}
}
# Assuming markers_of_interest is defined and has at least 4 elements
for(n in 1:9){
for (sel_idx in 1:4) {
selected_traj_data <- combined_df %>%
dplyr::filter(marker %in% markers_of_interest)
# Plot a single marker's x, y, and z values before gap filling
plot_before <- selected_traj_data %>%
dplyr::filter(group == n) %>%
dplyr::filter(marker == markers_of_interest[sel_idx]) %>%
ggplot(aes(x = elapsed_time, y = x, color=subject)) +
geom_line() +
facet_wrap(c(~condition)) +
labs(
x = "Elapsed time",
y = "Marker X position",
title = paste("Marker", markers_of_interest[sel_idx], "X position before gap filling", "group", n)
)
print(plot_before)
ggsave(
plot_before,
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"group",
n,
"_x_position_before_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# Apply the linear gap fill function to each column, by condition
selected_traj_data <- selected_traj_data %>%
group_by(condition, subject, marker) %>%
mutate_at(
vars(x, y, z),
~ gap_fill_linear(.)
)
# Plot a single marker's x, y, and z values after gap filling
plot_after <- selected_traj_data %>%
dplyr::filter(group == n) %>%
dplyr::filter(marker == markers_of_interest[sel_idx]) %>%
ggplot(aes(x = elapsed_time, y = x, color = subject)) +
geom_line() +
facet_wrap(c(~condition)) +
labs(
x = "Elapsed time",
y = "Marker X position",
title = paste("Marker", markers_of_interest[sel_idx], "X position after gap filling", "group", n)
)
print(plot_after)
ggsave(
plot_after,
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"group",
n,
"_x_position_after_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
}
}
## Setup chunk
=======
geom_smooth(se=FALSE)+
ylim(0, 6000)+
labs(
title = "DTW Values vs Social Dancing",
x = "EQ Score",
y = "DTW Value",
color = "Condition"
)+
scale_color_manual(values = aesthetic_highlight_difference_palette)
>>>>>>> Stashed changes
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
<<<<<<< Updated upstream
"fastICA",
"groupICA",
"dtw",
"dplyr"
)
## Making sure we are in the right directory
wd <- getwd()
if (basename(wd) != "PerceptionActionExam") {
setwd("./PerceptionActionExam")
}
# set the directory for the data
# note, path_home() will return the path to your home directory
# your home directory is the one that contains your documents, downloads, etc.
# data_dir <- path_home() %>%
#   path("Documents", "GitHub", "PerceptionActionExam", "data", "tsvs") ## Nadia's path
data_dir <- path_home() %>%
path("Desktop","UNI", "3.semester", "Perception & Action", "PerceptionActionExam", "data", "tsvs") ## Katharina's path
# The available conditions and their start and end frame indices
# to use the whole file, just set the value for the condition to c(NA, NA)
conditions <- list(
jointlead = c(NA, NA),
followlead = c(NA, NA),
leadfollow = c(NA, NA),
custom = c(NA, NA)
)
# Calling functions
source("Functions.R")
## the code lists files in the specified directory that have names ending with ".tsv" and stores the list of file paths in the variable traj_files.
traj_files <- fs::dir_ls(data_dir, regexp = "\\.tsv$")
# Now we can actually load in the data. When we are loading in the data, we are also renaming out list to be the name of the individual groups and conditions
traj_data_list <- list()
for (file_path in traj_files) {
# Load the data from the file
traj_data <- process_qtm_tsv(file_path)
# Extract the group number and condition from the filename
group_number <- sub(".*group([0-9]+).*\\.tsv", "\\1", basename(file_path))
condition <- traj_data$metadata$condition
# Create a unique identifier for the combination of group number and condition
group_condition_identifier <- paste0("group", group_number, "_", condition)
# Check if a dataframe with this identifier already exists in the list
if (group_condition_identifier %in% names(traj_data_list)) {
# If it exists, append the data to the existing dataframe
traj_data_list[[group_condition_identifier]]$data <- rbind(traj_data_list[[group_condition_identifier]]$data, traj_data$data)
} else {
# If it doesn't exist, create a new dataframe and add it to the list
traj_data_list[[group_condition_identifier]] <- traj_data
}
}
# Now, traj_data_list contains individual lists for each unique combination of group number and condition
traj_data_list <- lapply(traj_data_list, function(x) {
# Add condition and group information to the data frame
x$data$condition <- x$metadata$condition
# Set x$data$group to be the list name
x$data$group <- basename(file_path)
return(x)
})
library(dplyr)
# Assuming traj_data_list is a list of data frames with both 'data' and 'metadata'
for (i in seq_along(traj_data_list)) {
x <- traj_data_list[[i]]
# Check if 'data' and 'metadata' components exist in each list element
if (!all(c("data", "metadata") %in% names(x))) {
warning("List element does not have 'data' and/or 'metadata'. Skipping.")
next
}
# Extract condition and group information from the file path
file_path <- names(traj_data_list)[i]
condition <- sub(".*group[0-9]+_([^_\\.]+).*", "\\1", file_path)
group_number <- sub(".*group([0-9]+).*", "\\1", file_path)
# Add condition and group information to the data frame
x$data$condition <- condition
x$data$group <- paste0("group", group_number)
# Create a new data frame with the processed data and name it
new_df_name <- paste0("group", group_number, "_", condition)
assign(new_df_name, x$data)
}
# Get a list of objects in the global environment
all_objects <- ls()
# regex
regex_pattern <- "^group([0-9]|1[0-3])_"
# Filter objects that match the pattern
group_objects <- grep(regex_pattern, all_objects, value = TRUE)
# Loop through each object and apply the operations
for (df_name in group_objects) {
# Extract the current data frame
df <- get(df_name)
# Check if 'condition' and 'group' columns exist
if (!all(c("condition", "group") %in% names(df))) {
warning(paste("Data frame", df_name, "does not have 'condition' and/or 'group' columns. Skipping."))
next
}
# Add factors for condition and group
df$condition <- factor(df$condition)
df$group <- factor(df$group)
# Print the data frame name
cat("Data frame:", df_name, "\n")
# Print the first few rows of the data frame
print(head(df))
# Ensure all marker names are the same
marker_names <- unique(df %>% select(contains("_x")) %>% names() %>% stri_replace_last_regex("_x", ""))
assertthat::assert_that(
all(marker_names == traj_labels$traj_names),
msg = paste("Not all marker names are the same in Data frame", df_name)
)
cat("\n")
}
## Setup chunk
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
=======
"ggplot2",
"hrbrthemes",
"lme4"
)
#Aesthetic setup
theme_set(theme_ipsum(base_family = "Times New Roman"))
global_fill_colour <- "#8d5b5a"
aesthetic_palette <- c(
"#d8aeb5","#c17f8c","#b59592","#9b6f69","#a94f62","#8d5b5a","#684141","#733545","#523438","#48222b","#2f1a1b")
aesthetic_highlight_difference_palette <- c("#d8aeb5","#2f1a1b")
model <- lmer(DTW_score ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | ParticipantID), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | 'Participant ID'), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | Participant ID), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score, data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 + Age + Gender | `Participant ID`), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
"ggplot2",
"hrbrthemes",
"Matrix",
"lme4"
)
#Aesthetic setup
theme_set(theme_ipsum(base_family = "Times New Roman"))
global_fill_colour <- "#8d5b5a"
aesthetic_palette <- c(
"#d8aeb5","#c17f8c","#b59592","#9b6f69","#a94f62","#8d5b5a","#684141","#733545","#523438","#48222b","#2f1a1b")
aesthetic_highlight_difference_palette <- c("#d8aeb5","#2f1a1b")
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
library(Matrix)
library(lme4)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
>>>>>>> Stashed changes
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
<<<<<<< Updated upstream
"fastICA",
"groupICA",
"dtw",
"dplyr"
)
## Making sure we are in the right directory
wd <- getwd()
if (basename(wd) != "PerceptionActionExam") {
setwd("./PerceptionActionExam")
}
# set the directory for the data
# note, path_home() will return the path to your home directory
# your home directory is the one that contains your documents, downloads, etc.
# data_dir <- path_home() %>%
#   path("Documents", "GitHub", "PerceptionActionExam", "data", "tsvs") ## Nadia's path
data_dir <- path_home() %>%
path("Desktop","UNI", "3.semester", "Perception & Action", "PerceptionActionExam", "data", "tsvs") ## Katharina's path
# The available conditions and their start and end frame indices
# to use the whole file, just set the value for the condition to c(NA, NA)
conditions <- list(
jointlead = c(NA, NA),
followlead = c(NA, NA),
leadfollow = c(NA, NA),
custom = c(NA, NA)
)
# Calling functions
source("Functions.R")
# load the labels from the XML file
# load the XML file
xmlfile <- xmlParse("PerAct23_LabelList.xml")
# get the labels, which are in the following format:
# <QTM_Label_List_Ver_1.00>
#     <Trajectories>
#         <Trajectory>
#             <Name>A_head_top</Name>
#             <Color R="0" G="147" B="0"/>
#         </Trajectory>
#     </Trajectories>
# </QTM_Label_List_Ver_1.00>
# get the trajectory names
traj_names <- xpathSApply(xmlfile, "//Trajectory/Name", xmlValue)
# get the trajectory colors
traj_colors <- xpathSApply(xmlfile, "//Trajectory/Color", xmlAttrs)
# convert the colors to hex
traj_colors <- rgb(
as.numeric(traj_colors[1,]),
as.numeric(traj_colors[2,]),
as.numeric(traj_colors[3,]),
alpha = 255,
maxColorValue = 255
)
# combine the names and colors into a data frame
traj_labels <- data.frame(
traj_names,
traj_colors,
stringsAsFactors = FALSE
)
rm(xmlfile, traj_names, traj_colors)
## the code lists files in the specified directory that have names ending with ".tsv" and stores the list of file paths in the variable traj_files.
traj_files <- fs::dir_ls(data_dir, regexp = "\\.tsv$")
# Now we can actually load in the data. When we are loading in the data, we are also renaming out list to be the name of the individual groups and conditions
traj_data_list <- list()
for (file_path in traj_files) {
# Load the data from the file
traj_data <- process_qtm_tsv(file_path)
# Extract the group number and condition from the filename
group_number <- sub(".*group([0-9]+).*\\.tsv", "\\1", basename(file_path))
condition <- traj_data$metadata$condition
# Create a unique identifier for the combination of group number and condition
group_condition_identifier <- paste0("group", group_number, "_", condition)
# Check if a dataframe with this identifier already exists in the list
if (group_condition_identifier %in% names(traj_data_list)) {
# If it exists, append the data to the existing dataframe
traj_data_list[[group_condition_identifier]]$data <- rbind(traj_data_list[[group_condition_identifier]]$data, traj_data$data)
} else {
# If it doesn't exist, create a new dataframe and add it to the list
traj_data_list[[group_condition_identifier]] <- traj_data
}
}
# Now, traj_data_list contains individual lists for each unique combination of group number and condition
traj_data_list <- lapply(traj_data_list, function(x) {
# Add condition and group information to the data frame
x$data$condition <- x$metadata$condition
# Set x$data$group to be the list name
x$data$group <- basename(file_path)
return(x)
})
library(dplyr)
# Assuming traj_data_list is a list of data frames with both 'data' and 'metadata'
for (i in seq_along(traj_data_list)) {
x <- traj_data_list[[i]]
# Check if 'data' and 'metadata' components exist in each list element
if (!all(c("data", "metadata") %in% names(x))) {
warning("List element does not have 'data' and/or 'metadata'. Skipping.")
next
}
# Extract condition and group information from the file path
file_path <- names(traj_data_list)[i]
condition <- sub(".*group[0-9]+_([^_\\.]+).*", "\\1", file_path)
group_number <- sub(".*group([0-9]+).*", "\\1", file_path)
# Add condition and group information to the data frame
x$data$condition <- condition
x$data$group <- paste0("group", group_number)
# Create a new data frame with the processed data and name it
new_df_name <- paste0("group", group_number, "_", condition)
assign(new_df_name, x$data)
}
# Get a list of objects in the global environment
all_objects <- ls()
# regex
regex_pattern <- "^group([0-9]|1[0-3])_"
# Filter objects that match the pattern
group_objects <- grep(regex_pattern, all_objects, value = TRUE)
# Loop through each object and apply the operations
for (df_name in group_objects) {
# Extract the current data frame
df <- get(df_name)
# Check if 'condition' and 'group' columns exist
if (!all(c("condition", "group") %in% names(df))) {
warning(paste("Data frame", df_name, "does not have 'condition' and/or 'group' columns. Skipping."))
next
}
# Add factors for condition and group
df$condition <- factor(df$condition)
df$group <- factor(df$group)
# Print the data frame name
cat("Data frame:", df_name, "\n")
# Print the first few rows of the data frame
print(head(df))
# Ensure all marker names are the same
marker_names <- unique(df %>% select(contains("_x")) %>% names() %>% stri_replace_last_regex("_x", ""))
assertthat::assert_that(
all(marker_names == traj_labels$traj_names),
msg = paste("Not all marker names are the same in Data frame", df_name)
)
cat("\n")
}
# Get a list of objects in the global environment
all_objects <- ls()
# Define a regular expression to match group identifiers followed by a number between 0 and 13
regex_pattern <- "^group([0-9]|1[0-3])_"
# Filter objects that match the pattern
group_objects <- grep(regex_pattern, all_objects, value = TRUE)
# Loop through each object and apply the operations
for (df_name in group_objects) {
# Extract the current data frame
df <- get(df_name)
# Check if 'condition' and 'group' columns exist
if (!all(c("condition", "group") %in% names(df))) {
warning(paste("Data frame", df_name, "does not have 'condition' and/or 'group' columns. Skipping."))
next
}
# Pivot the data
df <- df %>%
pivot_longer(
cols = contains("_x") | contains("_y") | contains("_z"),
cols_vary = "slowest",
names_to = "marker",
values_to = "value"
) %>%
mutate(
subject = stri_replace_first_regex(marker, "^([AB])_.*", "$1"),
axis = stri_extract_last_regex(marker, "[xyz]$"),
marker = stri_replace_first_regex(marker, "^[AB]_([a-zA-Z_]+)_[xyz]$", "$1")
) %>%
# Move axes to columns
pivot_wider(
names_from = axis,
values_from = value
)
# Assign the modified data frame back to the original variable
assign(df_name, df)
# Print the data frame name
cat("Data frame:", df_name, "\n")
# Print the first few rows of the pivoted data frame
print(head(df))
cat("\n")
}
View(group0_jointlead)
group8_leadfollow_sub <- group8_leadfollow
## checking class
class(group8_leadfollow_sub$subject)
## converting into factor
group8_leadfollow_sub$subject <- as.factor(group8_leadfollow_sub$subject)
## Plotting in 3D again, but just with time
fig <- plotly::plot_ly(group8_leadfollow_sub,
x = ~x,
y = ~y,
z = ~z,
type = "scatter3d",
mode = "markers",
size = 2,
frame = ~elapsed_time,
marker = list(size = 4), ## Adjusting the marker size
color = ~subject,
colors = c("pink", "steelblue4"))
fig <- fig %>% plotly::layout(
scene = list(
aspectmode = "cube"),
xaxis = list(title = "X-axis"),
yaxis = list(title = "Y-axis"),
zaxis = list(title = "Z-axis"))
fig <- fig %>% ## adding and changing text
plotly::layout(title = list(text = "Group 8", y = 0.9),
font=list(size=15, family = "Times new roman"),
legend = list(title = list(text = "markers")))
fig
library(rgl)
install.packages("rgl")
# Assuming 'df' is your dataframe with x, y, z, and time columns
# Sort your data by time just to be sure
df <- group0_jointlead[order(group0_jointlead$elapsed_time), ]
# Unique time points
time_points <- unique(df$elapsed_time)
# Initialize the plot with the first time point
first_time_data <- subset(df, elapsed_time == time_points[1])
plot3d(first_time_data$x, first_time_data$y, first_time_data$z, col = "blue", size = 3)
=======
"ggplot2",
"hrbrthemes",
"Matrix",
"lme4"
)
#Aesthetic setup
theme_set(theme_ipsum(base_family = "Times New Roman"))
global_fill_colour <- "#8d5b5a"
aesthetic_palette <- c(
"#d8aeb5","#c17f8c","#b59592","#9b6f69","#a94f62","#8d5b5a","#684141","#733545","#523438","#48222b","#2f1a1b")
aesthetic_highlight_difference_palette <- c("#d8aeb5","#2f1a1b")
install.packages("Matrix")
library(Matrix)
library(lme4)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
install.packages("Matrix")
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
>>>>>>> Stashed changes
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
<<<<<<< Updated upstream
"fastICA",
"groupICA",
"dtw",
"dplyr",
"rgl"
)
## Making sure we are in the right directory
wd <- getwd()
if (basename(wd) != "PerceptionActionExam") {
setwd("./PerceptionActionExam")
}
# set the directory for the data
# note, path_home() will return the path to your home directory
# your home directory is the one that contains your documents, downloads, etc.
# data_dir <- path_home() %>%
#   path("Documents", "GitHub", "PerceptionActionExam", "data", "tsvs") ## Nadia's path
data_dir <- path_home() %>%
path("Desktop","UNI", "3.semester", "Perception & Action", "PerceptionActionExam", "data", "tsvs") ## Katharina's path
# The available conditions and their start and end frame indices
# to use the whole file, just set the value for the condition to c(NA, NA)
conditions <- list(
jointlead = c(NA, NA),
followlead = c(NA, NA),
leadfollow = c(NA, NA),
custom = c(NA, NA)
)
# Calling functions
source("Functions.R")
# Assuming 'df' is your dataframe with x, y, z, and time columns
# Sort your data by time just to be sure
df <- group0_jointlead[order(group0_jointlead$elapsed_time), ]
# Unique time points
time_points <- unique(df$elapsed_time)
# Initialize the plot with the first time point
first_time_data <- subset(df, elapsed_time == time_points[1])
plot3d(first_time_data$x, first_time_data$y, first_time_data$z, col = "blue", size = 3)
library(rgl)
=======
"ggplot2",
"hrbrthemes",
"Matrix",
"lme4"
)
#Aesthetic setup
theme_set(theme_ipsum(base_family = "Times New Roman"))
global_fill_colour <- "#8d5b5a"
aesthetic_palette <- c(
"#d8aeb5","#c17f8c","#b59592","#9b6f69","#a94f62","#8d5b5a","#684141","#733545","#523438","#48222b","#2f1a1b")
aesthetic_highlight_difference_palette <- c("#d8aeb5","#2f1a1b")
library(Matrix)
library(lme4)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
library(Matrix)
library(lme4)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
summary(model)
qqnorm(resid(model))
qqline(resid(model), col = "red")
plot(fitted(model), resid(model))
abline(h = 0, col = "red")
plot(fitted(model), resid(model))
abline(h = 0, col = "red")
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
"ggplot2",
"hrbrthemes",
"Matrix",
"lme4",
"lmerTest"
)
#Aesthetic setup
theme_set(theme_ipsum(base_family = "Times New Roman"))
global_fill_colour <- "#8d5b5a"
aesthetic_palette <- c(
"#d8aeb5","#c17f8c","#b59592","#9b6f69","#a94f62","#8d5b5a","#684141","#733545","#523438","#48222b","#2f1a1b")
aesthetic_highlight_difference_palette <- c("#d8aeb5","#2f1a1b")
library(influence.ME)
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
"ggplot2",
"hrbrthemes",
"Matrix",
"lme4",
"lmerTest"
)
#Aesthetic setup
theme_set(theme_ipsum(base_family = "Times New Roman"))
global_fill_colour <- "#8d5b5a"
aesthetic_palette <- c(
"#d8aeb5","#c17f8c","#b59592","#9b6f69","#a94f62","#8d5b5a","#684141","#733545","#523438","#48222b","#2f1a1b")
aesthetic_highlight_difference_palette <- c("#d8aeb5","#2f1a1b")
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
"ggplot2",
"hrbrthemes",
"Matrix",
"lme4",
"lmerTest",
"influence.ME"
)
#Aesthetic setup
theme_set(theme_ipsum(base_family = "Times New Roman"))
global_fill_colour <- "#8d5b5a"
aesthetic_palette <- c(
"#d8aeb5","#c17f8c","#b59592","#9b6f69","#a94f62","#8d5b5a","#684141","#733545","#523438","#48222b","#2f1a1b")
aesthetic_highlight_difference_palette <- c("#d8aeb5","#2f1a1b")
library(influence.ME)
influence <- influence(model)
library(influence.ME)
influence_obs <- influence(model, obs = TRUE)
plot(influence_obs, which = "cooks")
library(influence.ME)
influence_obs <- influence(model, obs = TRUE)
plot(influence_obs, which = "cooks")
library(influence.ME)
influence_obs <- influence(model, obs = TRUE)
plot(influence_obs, which = "cooks")
View(influence_obs)
library(influence.ME)
influence_obs <- influence(model, obs = TRUE)
plot(influence_obs, which = "cooks")
str(influence_obs)
library(influence.ME)
influence_obs <- influence(model, obs = TRUE)
plot(influence_obs, which = "cooks")
str(influence_obs)
library(influence.ME)
influence_obs <- influence(model, obs = TRUE)
plot(influence_obs)
library(influence.ME)
influence_obs <- influence(model, obs = TRUE)
influence.ME::plot(influence_obs, which = "cooks")
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = 4 / length(cooks_dist), col = "red", lty = 2)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = 4 / length(cooks_dist), col = "red", lty = 2)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = 4 / length(cooks_dist), col = "red", lty = 2)+
ggtitle("weee")
cooks_dist <- cooks.distance(model)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = 4 / length(cooks_dist), col = "red", lty = 2)
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = threshold), col = "red", lty = 2)
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = threshold), col = "red", lty = 2)
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = threshold, col = "red", lty = 2)
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = threshold, col = "red", lty = 2)
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Plot Cook's distance
plot(cooks_dist, type = "h", ylab = "Cook's Distance", xlab = "Observation Index")
abline(h = threshold, col = "red", lty = 2)
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = "blue") +
labs(title = "Cook's Distance: Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: ",
subtitle = "Visualising Especially Important Observations"
y = "Cook's Distance",
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: ",
subtitle = "Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: ",
subtitle = "Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: ",
subtitle = "Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")+
scale_fill_manual(values = aesthetic_highlight_difference_palette)
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: ",
subtitle = "Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")+
scale_color_manual(values = aesthetic_highlight_difference_palette)
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
View(model)
View(complete_df)
View(complete_df)
library(Matrix)
library(lme4)
model <- lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`+Gender), data = complete_df)
library(Matrix)
library(lme4)
model <- lme4::lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`+Gender), data = complete_df)
library(Matrix)
library(lme4)
model <- lme4::lmer(DTW_Value ~ EQ_score + DTW_Type + Gender Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
library(Matrix)
library(lme4)
model <- lme4::lmer(DTW_Value ~ EQ_score + DTW_Type + Gender + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
qqnorm(resid(model))
qqline(resid(model), col = "red")
plot(fitted(model), resid(model))
abline(h = 0, col = "red")
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: ",
subtitle = "Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
library(Matrix)
library(lme4)
model <- lme4::lmer(DTW_Value ~ EQ_score + DTW_Type + Factor1_BodyAwareness_score + Factor2_SocialDancing_score + (1 | `Participant ID`), data = complete_df)
# Calculate Cook's distance
cooks_dist <- cooks.distance(model)
# Calculate the threshold
threshold <- 4 / length(cooks_dist)
# Create a data frame for plotting
cooks_df <- data.frame(Index = 1:length(cooks_dist), CooksDistance = cooks_dist)
# Plot Cook's distance using ggplot2
ggplot(cooks_df, aes(x = Index, y = CooksDistance)) +
geom_hline(yintercept = threshold, linetype = "dashed", color = "red") +
geom_segment(aes(x = Index, xend = Index, y = 0, yend = CooksDistance), color = global_fill_colour) +
labs(title = "Cook's Distance: ",
subtitle = "Visualising Especially Important Observations",
y = "Cook's Distance",
x = "Observation Index")
# Find observations where Cook's distance exceeds the threshold
influential_obs <- which(cooks_dist > threshold)
# Print the indices of these observations
print(influential_obs)
summary(model)
summary(model)
lmerTest::summary(model)
library(lme4)
library(lmerTest)
summary(model)
library(lme4)
library(lmerTest)
summary(model)
install.packages(lmerTest)
library(lme4)
library(lmerTest)
summary(model)
>>>>>>> Stashed changes

jointlead = c(NA, NA),
followlead = c(NA, NA),
leadfollow = c(NA, NA),
custom = c(NA, NA)
)
# Calling functions
source("Functions.R")
# load the labels from the XML file
# load the XML file
xmlfile <- xmlParse("PerAct23_LabelList.xml")
# get the labels, which are in the following format:
# <QTM_Label_List_Ver_1.00>
#     <Trajectories>
#         <Trajectory>
#             <Name>A_head_top</Name>
#             <Color R="0" G="147" B="0"/>
#         </Trajectory>
#     </Trajectories>
# </QTM_Label_List_Ver_1.00>
# get the trajectory names
traj_names <- xpathSApply(xmlfile, "//Trajectory/Name", xmlValue)
# get the trajectory colors
traj_colors <- xpathSApply(xmlfile, "//Trajectory/Color", xmlAttrs)
# convert the colors to hex
traj_colors <- rgb(
as.numeric(traj_colors[1,]),
as.numeric(traj_colors[2,]),
as.numeric(traj_colors[3,]),
alpha = 255,
maxColorValue = 255
)
# combine the names and colors into a data frame
traj_labels <- data.frame(
traj_names,
traj_colors,
stringsAsFactors = FALSE
)
#deleting the files that we wont use anymore, so the workspace isn't cluttered
rm(xmlfile, traj_names, traj_colors)
## this loads in all the files
traj_files <- fs::dir_ls(data_dir, regexp = "\\.tsv$")
# load the trajectory data, we want all TSVs with the group number in the name
# get the files
traj_files <- fs::dir_ls(data_dir, regexp = paste0("group", group_number, "_.*\\.tsv$"))
# load the data
traj_data <- lapply(traj_files, process_qtm_tsv)
# now we need to combine the data into a single data frame
# first we need to add the condition and group to each data frame
traj_data <- lapply(traj_data, function(x) {
x$data$condition <- x$metadata$condition
x$data$group <- paste0("group", group_number)
return(x)
})
# now we can combine the data
traj_data <- do.call(bind_rows, lapply(traj_data, `[[`, "data"))
# make the condition and group factors
traj_data$condition <- factor(traj_data$condition)
traj_data$group <- factor(traj_data$group)
# take a look at the data
head(traj_data)
# let's also make sure that all of the marker names are the same
# we can do this by getting the unique marker names
marker_names <- unique(traj_data %>% select(contains("_x")) %>% names() %>% stri_replace_last_regex("_x", ""))
# now we can check that all of the marker names are the same
assertthat::assert_that(
all(marker_names == traj_labels$traj_names),
msg = "Not all marker names are the same"
)
# let's make the data long format so we can easily group by subject or marker
traj_data <- traj_data %>%
pivot_longer(
cols = contains("_x") | contains("_y") | contains("_z"),
cols_vary = "slowest",
names_to = "marker",
values_to = "value"
) %>%
mutate(
subject = stri_replace_first_regex(marker, "^([AB])_.*", "$1"),
axis = stri_extract_last_regex(marker, "[xyz]$"),
marker = stri_replace_first_regex(marker, "^[AB]_([a-zA-Z_]+)_[xyz]$", "$1")
)
# move axes to columns
traj_data <- traj_data %>%
pivot_wider(
names_from = axis,
values_from = value
)
# Making sure that we have all of the different markers HEHEHEEH HI KAT
unique(traj_data$marker)
#traj_data$marker <- factor(traj_data$marker, levels = marker_names) ## i cant remember why this is here, but i think it is important later.
View(traj_data)
# We want to crop the data for each condition
# let's get all the recorded conditions
recorded_conditions <- unique(traj_data$condition)
for (cond in recorded_conditions) {
# get the start and end frame for the condition
start_frame <- conditions[[cond]][1]
if (is.na(start_frame)) start_frame <- 1
end_frame <- conditions[[cond]][2]
if (is.na(end_frame)) end_frame <- max(traj_data[traj_data$condition == cond, "index"])
# crop the data
traj_data <- traj_data %>%
dplyr::filter(condition == cond & index >= start_frame & index <= end_frame | condition != cond)
}
# select min and max indices by condition
traj_data %>%
group_by(condition) %>%
summarise(
min_index = min(index),
max_index = max(index))
# report observations per condition
traj_data %>%
group_by(condition, subject, marker) %>%
summarise(
n_obs = n()
) %>%
print(n = 100)
## Filtering out custom condition
traj_data <- traj_data %>%
dplyr::filter(condition %in% c("leadfollow", "followlead", "jointlead")) ## a bit confused why this works
## Checking to see if the filtering worked :)
traj_data %>%
distinct(condition)
# we want to check for large jumps in the data
# this indicates potential label errors
# we will do this by calculating the distance between each marker for each time point
# of course, by condition
# calculate the euclidean distance between each marker (using x, y, z)
# we will do this by condition, subject, marker and axis
marker_distances <- traj_data %>%
group_by(condition, subject, marker) %>%
arrange(index) %>%
mutate(
diff_x = x - dplyr::lag(x, 1),
diff_y = y - dplyr::lag(y, 1),
diff_z = z - dplyr::lag(z, 1)
)
# now we can calculate the euclidean distance per maker
marker_distances <- marker_distances %>%
mutate(
euclidean_distance = sqrt(diff_x^2 + diff_y^2 + diff_z^2)
)
# now we can plot the series for each marker, and see if anything stands out
marker_distances %>%
ggplot(aes(x = index, y = euclidean_distance)) +
geom_line(aes(color = factor(marker)), linewidth=1.25) +
theme_minimal() +
facet_wrap(c(~condition, ~subject)) +
labs(
x = "Index",
y = "Euclidean distance",
title = "Euclidean distance from previous frame by marker"
)
# save the plot
ggsave(
filename = "./results/euclidean_distance_by_marker.png",
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# get NAs counts
# by condition, marker, subject and axis
nas_cond_marker <- traj_data %>%
group_by(condition, subject, marker) %>%
summarise_at(
vars(x, y, z),
~ sum(is.na(.))
)
# plot to check if it is acceptable
nas_cond_marker %>%
ggplot(aes(x = marker, y = x, fill=marker, group=subject)) +
geom_col(
show.legend = FALSE
) +
coord_flip() +
theme_minimal() +
facet_wrap(c(~subject, ~condition)) +
labs(
x = "Marker",
y = "NA count",
title = "NA count by marker"
)
ggsave(
filename = "./results/NA_count_by_marker.png",
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# Now we can get the longest sequence of NAs for each marker
longest_na_seq <- traj_data %>%
group_by(condition, subject, marker) %>%
summarise_at(
vars(x, y, z),
~ max(rle(is.na(.))$lengths)
)
# plot to check if it is acceptable
longest_na_seq %>%
ggplot(aes(x = marker, y = x, fill=marker, group=subject)) +
geom_col(
show.legend = FALSE
) +
coord_flip() +
theme_minimal() +
facet_wrap(c(~subject, ~condition)) +
labs(
x = "Marker",
y = "Longest NA sequence",
title = "Longest NA sequence by marker"
)
ggsave(
filename = "./results/longest_na_sequence_by_marker.png",
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# we want to choose the markers of interest
# we will choose the following markers:
# - {A,B}_head_top
# - {A,B}_hand_right
# you may of course choose different markers, or if those ones were
# particularly bad, you should select others
# get the markers of interest
markers_of_interest <- c(
"hand_right"
)
# now we can select the markers of interest
selected_traj_data <- traj_data %>%
dplyr::filter(marker %in% markers_of_interest)
# we are only going to do a linear gap fill, it's not elegant, but it works
# we will do this for each marker x, y, and z
# choose a single marker from markers_of_interest for plotting purposes only
sel_idx = 1
# plot a single marker's x, y, and z values before and after gap filling
selected_traj_data %>%
dplyr::filter(marker == markers_of_interest[sel_idx]) %>%
ggplot(aes(x = elapsed_time, y = x, color = subject)) +
geom_line() +
theme_minimal() +
facet_wrap(c(~condition)) +
labs(
x = "Elapsed time",
y = "Marker X position",
title = paste("Marker", markers_of_interest[sel_idx], "X position before gap filling")
)
ggsave(
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"_x_position_before_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# now we can apply our linear gap fill function to each column, by condition
selected_traj_data <- selected_traj_data %>%
group_by(condition, subject, marker) %>%
mutate_at(
vars(x, y, z),
~ gap_fill_linear(.)
)
# plot a single marker's x, y, and z after gap filling
selected_traj_data %>%
dplyr::filter(marker == markers_of_interest[sel_idx]) %>%
ggplot(aes(x = elapsed_time, y = x, color = subject)) +
geom_line() +
theme_minimal() +
facet_wrap(c(~condition)) +
labs(
x = "Elapsed time",
y = "Marker X position",
title = paste("Marker", markers_of_interest[sel_idx], "X position after gap filling")
)
ggsave(
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"_x_position_after_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
## Filtering out custom condition
traj_data <- traj_data %>%
dplyr::filter(condition %in% c("leadfollow", "followlead", "jointlead")) ## a bit confused why this works
## Checking to see if the filtering worked :)
traj_data %>%
distinct(condition)
# we want to check for large jumps in the data
# this indicates potential label errors
# we will do this by calculating the distance between each marker for each time point
# of course, by condition
# calculate the euclidean distance between each marker (using x, y, z)
# we will do this by condition, subject, marker and axis
marker_distances <- traj_data %>%
group_by(condition, subject, marker) %>%
arrange(index) %>%
mutate(
diff_x = x - dplyr::lag(x, 1),
diff_y = y - dplyr::lag(y, 1),
diff_z = z - dplyr::lag(z, 1)
)
# now we can calculate the euclidean distance per maker
marker_distances <- marker_distances %>%
mutate(
euclidean_distance = sqrt(diff_x^2 + diff_y^2 + diff_z^2)
)
# now we can plot the series for each marker, and see if anything stands out
marker_distances %>%
ggplot(aes(x = index, y = euclidean_distance)) +
geom_line(aes(color = factor(marker)), linewidth=1.25) +
theme_minimal() +
facet_wrap(c(~condition, ~subject)) +
labs(
x = "Index",
y = "Euclidean distance",
title = "Euclidean distance from previous frame by marker"
)
# save the plot
ggsave(
filename = "./results/euclidean_distance_by_marker.png",
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# get NAs counts
# by condition, marker, subject and axis
nas_cond_marker <- traj_data %>%
group_by(condition, subject, marker) %>%
summarise_at(
vars(x, y, z),
~ sum(is.na(.))
)
# plot to check if it is acceptable
nas_cond_marker %>%
ggplot(aes(x = marker, y = x, fill=marker, group=subject)) +
geom_col(
show.legend = FALSE
) +
coord_flip() +
theme_minimal() +
facet_wrap(c(~subject, ~condition)) +
labs(
x = "Marker",
y = "NA count",
title = "NA count by marker"
)
ggsave(
filename = "./results/NA_count_by_marker.png",
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# Now we can get the longest sequence of NAs for each marker
longest_na_seq <- traj_data %>%
group_by(condition, subject, marker) %>%
summarise_at(
vars(x, y, z),
~ max(rle(is.na(.))$lengths)
)
# plot to check if it is acceptable
longest_na_seq %>%
ggplot(aes(x = marker, y = x, fill=marker, group=subject)) +
geom_col(
show.legend = FALSE
) +
coord_flip() +
theme_minimal() +
facet_wrap(c(~subject, ~condition)) +
labs(
x = "Marker",
y = "Longest NA sequence",
title = "Longest NA sequence by marker"
)
ggsave(
filename = "./results/longest_na_sequence_by_marker.png",
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# we want to choose the markers of interest
# we will choose the following markers:
# - {A,B}_head_top
# - {A,B}_hand_right
# you may of course choose different markers, or if those ones were
# particularly bad, you should select others
# get the markers of interest
markers_of_interest <- c(
"hand_right"
)
# now we can select the markers of interest
selected_traj_data <- traj_data %>%
dplyr::filter(marker %in% markers_of_interest)
# we are only going to do a linear gap fill, it's not elegant, but it works
# we will do this for each marker x, y, and z
# choose a single marker from markers_of_interest for plotting purposes only
sel_idx = 1
# plot a single marker's x, y, and z values before and after gap filling
selected_traj_data %>%
dplyr::filter(marker == markers_of_interest[sel_idx]) %>%
ggplot(aes(x = elapsed_time, y = x, color = subject)) +
geom_line() +
theme_minimal() +
facet_wrap(c(~condition)) +
labs(
x = "Elapsed time",
y = "Marker X position",
title = paste("Marker", markers_of_interest[sel_idx], "X position before gap filling")
)
ggsave(
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"_x_position_before_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
# now we can apply our linear gap fill function to each column, by condition
selected_traj_data <- selected_traj_data %>%
group_by(condition, subject, marker) %>%
mutate_at(
vars(x, y, z),
~ gap_fill_linear(.)
)
# plot a single marker's x, y, and z after gap filling
selected_traj_data %>%
dplyr::filter(marker == markers_of_interest[sel_idx]) %>%
ggplot(aes(x = elapsed_time, y = x, color = subject)) +
geom_line() +
theme_minimal() +
facet_wrap(c(~condition)) +
labs(
x = "Elapsed time",
y = "Marker X position",
title = paste("Marker", markers_of_interest[sel_idx], "X position after gap filling")
)
ggsave(
filename = paste0(
"./results/marker_",
markers_of_interest[sel_idx],
"_x_position_after_gap_filling.png"),
width = 10,
height = 10,
units = "cm",
dpi = 300
)
#dataframe with hand_right marker being converted to matrix
x <- data.matrix(followlead_8)
followlead_8 <- selected_traj_data %>%
dplyr::filter(condition == "followlead")
#dataframe with hand_right marker being converted to matrix
x <- data.matrix(followlead_8)
## We should try different functions
a <- fastICA(x, 3, alg.typ = "parallel", fun = "logcosh", alpha = 1,
method = "R", row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = TRUE)
## side note: neg-entropy is a way of measuring how much a distribution deviates from a Gaussian distribution. We want to maximize neg-entropy because it maximizes independence, which is the whole purpose of ICA.
knitr::opts_chunk$set(echo = TRUE, include = TRUE, message = FALSE, warning = FALSE)
#Calling functions
source("Functions.R")
#Calling packages
pacman::p_load(
"XML",
"tidyverse",
"fs",
"assertthat",
"stringi",
"dtw",
"RTransferEntropy",
"signal",
"conflicted",
"Rcpp",
"future",
"ggplot2",
"hrbrthemes"
)
#Aesthetic setup
theme_set(theme_ipsum())
bar_colour <- "#0e3b85"
#No 9 or 11 :) the data jumps.
#Unknown data could be: A1, A6
personality_questionnaire <- read_csv('data/PercAct23_Mocap_personality_questionnaires.csv')%>%
dplyr::filter(`I was a participant in the Mocap workshop`=="Yep") %>%
mutate(`Participant ID` = case_when(
`Participant ID` == "7A" ~ "A7",
`Participant ID` == "b12" ~ "B12",
`Participant ID` == "6b" ~ "B6",
`Participant ID` == "12 A" ~ "A12",
`Participant ID` == "B01" ~ "B1",
`Participant ID` == "A" ~ "A6",
`Participant ID` == "nnn" ~ "A1",
`Participant ID` == "H7" ~ "A13",
TRUE ~ `Participant ID`  # If no match, keep the original value
))
empathy_questionnaire <- personality_questionnaire %>%
select(
"Participant ID",
"Gender",
"Age",
starts_with("Question")
)
# Function for computing EQ-short-quotient for each row and adding it as a column
View(empathy_questionnaire)
